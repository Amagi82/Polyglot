package generators

import locales.LocaleIsoCode
import resources.Platform
import resources.Plural
import resources.Quantity
import resources.Resource
import resources.Str
import resources.StringArray
import locales.isDefault
import org.w3c.dom.Document
import org.w3c.dom.Element
import java.io.*
import java.lang.StringBuilder
import javax.xml.transform.OutputKeys
import javax.xml.transform.Transformer

/**
 * Generates iOS resources for a given language in the specified folder
 * This creates separate files for String resources, Plurals, and Arrays, which each use different
 * file types and formatting. It also generates an R file for type-safe resource access, e.g.
 * R.string.some_resource_id or R.plural.some_plural_id(quantity: 3, arg0: 3, arg1: "Mice") or
 * R.array.some_array_id, similar to Android, but providing the actual resource, not an integer.
 * Swift extension functions are generated for convenience.
 */
class IosResourceGenerator(private val iosFolder: File, locale: LocaleIsoCode, formatters: List<StringFormatter>, resources: Collection<Resource>) :
    ResourceGenerator(locale, formatters) {
    override val platform: Platform get() = Platform.iOS
    private val localizationFolder = File(iosFolder, "$locale.lproj").also(File::mkdirs)

    private val stringsWriter = BufferedWriter(FileWriter(localizationFolder.createChildFile("Localizable.strings")))

    private val pluralsDocument: Document = createDocument()
    private val pluralsResourceElement: Element = pluralsDocument.createAndAppendPlistElement()

    private val arraysDocument: Document = createDocument()
    private val arraysResourceElement: Element = arraysDocument.createAndAppendPlistElement()

    private val shouldCreatePlurals = resources.any { it is Plural }
    private val shouldCreateArrays = resources.any { it is StringArray }

    private val shouldCreateReferences = locale.isDefault
    private val stringReferences = if (shouldCreateReferences) StringBuilder() else null
    private val pluralReferences = if (shouldCreateReferences) StringBuilder() else null
    private val stringArrayReferences = if (shouldCreateReferences) StringBuilder() else null

    private val generatedFileWarning = """
        /*
        * This is a generated file, do not edit!
        * Generated by Polyglot
        */
        
    """.trimIndent()

    init {
        if (shouldCreateReferences) {
            iosFolder.listFiles { file -> file.name == "R.swift" }?.forEach(File::delete)
        }
        addAll(resources)
    }

    override fun generateFiles() {
        stringsWriter.close()
        if (shouldCreatePlurals) {
            transformer.transform(pluralsDocument, localizationFolder, "Localizable.stringsdict")
        }
        if (shouldCreateArrays) {
            transformer.transform(arraysDocument, localizationFolder, "LocalizableArrays.plist")
        }
        generateReferences()
        generateStringLocalizationExtensions()
    }

    override fun addString(res: Str) {
        // "identifier" = "Localized text";
        val txt = res.localizations.getRequired(locale).sanitized(isXml = false)
        stringsWriter.appendLine("\"${res.id}\" = \"$txt\";")
        stringReferences?.apply {
            appendLine()
            appendReferenceComment(txt)
            if (txt.contains('%')) appendReferenceFormattingArgs(res.id, txt, false)
            else appendLine("\t\tstatic let ${res.id} = \"${res.id}\".localized()")
        }
    }

    /**
     * <key>duration_days</key>
     * <dict>
     *   <key>NSStringLocalizedFormatKey</key>
     *   <string>%#@value@</string>
     *   <key>value</key>
     *   <dict>
     *       <key>NSStringFormatSpecTypeKey</key>
     *       <string>NSStringPluralRuleType</string>
     *       <key>NSStringFormatValueTypeKey</key>
     *       <string>d</string>
     *       <key>one</key>
     *       <string>%d day</string>
     *       <key>other</key>
     *       <string>%d days</string>
     *   </dict>
     * </dict>
     */
    override fun addPlurals(res: Plural) {
        var exampleText: String? = null
        pluralsResourceElement.appendChild(pluralsDocument, KEY, res.id)
        pluralsResourceElement.appendChild(pluralsDocument.createElement("dict").apply {
            appendChild(pluralsDocument, KEY, "NSStringLocalizedFormatKey")
            appendChild(pluralsDocument, STRING, "%#@value@")
            appendChild(pluralsDocument, KEY, "value")
            appendChild(pluralsDocument.createElement("dict").apply {
                appendChild(pluralsDocument, KEY, "NSStringFormatSpecTypeKey")
                appendChild(pluralsDocument, STRING, "NSStringPluralRuleType")
                appendChild(pluralsDocument, KEY, "NSStringFormatValueTypeKey")
                appendChild(pluralsDocument, STRING, "d")
                Quantity.values().forEach { quantity ->
                    val item = res.quantity(quantity) ?: return@forEach
                    val txt = (item.get(locale, isRequired = quantity.isRequired) ?: return@forEach).sanitized(isXml = true)
                    if (exampleText == null) exampleText = txt
                    appendChild(pluralsDocument, KEY, quantity.label)
                    appendChild(pluralsDocument, STRING, txt)
                }
            })
        })
        pluralReferences?.apply {
            appendLine()
            appendReferenceComment(exampleText.orEmpty())
            appendReferenceFormattingArgs(res.id, exampleText.orEmpty(), true)
        }
    }

    /**
     * <key>alert_cancel_reasons</key>
     * <array>
     *   <string>Time</string>
     *   <string>Wage</string>
     * </array>
     */
    override fun addStringArray(res: StringArray) {
        arraysResourceElement.appendChild(arraysDocument, KEY, res.id)
        arraysResourceElement.appendChild(arraysDocument.createElement("array").apply {
            for (item in res.items) {
                appendChild(arraysDocument, STRING, item.getRequired(locale).sanitized(isXml = true))
            }
        })
        stringArrayReferences?.apply {
            appendLine()
            appendLine("\t\tstatic let ${res.id} = \"${res.id}\".localizedArray()")
        }
    }

    private fun StringBuilder.appendReferenceComment(exampleText: String) {
        appendLine()
        if (exampleText.isNotEmpty()) appendLine("\t\t// en: $exampleText")
    }

    private fun StringBuilder.appendReferenceFormattingArgs(id: String, exampleText: String, isPlural: Boolean) {
        var i = exampleText.indexOf('%')

        append("\t\tstatic func $id(")
        if (isPlural) {
            append("quantity: Int")
            if (i != -1) append(", ")
        }

        var ct = 0
        while (i != -1) {
            val type = when (exampleText.getOrNull(i + 1)) {
                '@' -> "String"
                'd' -> "Int"
                'f' -> "Float"
                else -> null
            }
            if (type != null) {
                if (ct != 0) append(", ")
                append("_ arg$ct: $type")
                ct++
            }
            i = exampleText.indexOf('%', i + 1)
        }
        appendLine(") -> String {")
        append("\t\t\t\"$id\".localized")

        if (isPlural) {
            append("resources.Plural(quantity: quantity")
            if (ct > 0) append(", ")
        } else append('(')

        (0 until ct).forEach {
            if (it != 0) append(", ")
            append("arg$it")
        }
        appendLine(')')
        appendLine("\t\t}")
    }

    private fun generateReferences() {
        if (!shouldCreateReferences) return
        iosFolder.createChildFile("R.swift").bufferedWriter().use {
            it.appendLine(generatedFileWarning)
            it.appendLine("struct R {")
            it.appendReferences("string", stringReferences)
            it.appendReferences("plural", pluralReferences)
            it.appendReferences("array", stringArrayReferences)
            it.appendLine('}')
        }
    }

    private fun BufferedWriter.appendReferences(type: String, references: StringBuilder?) {
        if (references.isNullOrEmpty()) return
        appendLine("\tstruct $type {")
        append(references)
        appendLine("\t}")
    }

    private fun generateStringLocalizationExtensions() {
        if (iosFolder.listFiles().orEmpty().any { it.name == "String+Localization.swift" }) return
        iosFolder.createChildFile("String+Localization.swift").bufferedWriter().use {
            it.appendLine(generatedFileWarning)
            it.appendLine(
                """
                import Foundation
                
                extension String {
                
                    /*
                     * Returns a localized string. If the key is not found, it will default to using itself.
                     */
                    func localized() -> String {
                        NSLocalizedString(self, value: self, comment: "")
                    }
                    
                    /*
                     * Returns a localized string formatted with any args, using self as the key. It will default to
                     * using itself if no value is found for the key.
                     */
                    func localized(_ args: CVarArg...) -> String {
                        String(format: NSLocalizedString(self, value: self, comment: ""), arguments: args)
                    }
                    
                    func localizedPlural(quantity: Int, _ args: CVarArg...) -> String {
                        var args = args
                        args.insert(quantity, at: 0)
                        return String(format: NSLocalizedString(self, value: self, comment: ""), arguments: args)
                    }
                    
                    func localizedArray() -> [String] {
                        localizedDict?[self] as? [String] ?? []
                    }
                }
                
                private var localizedDict: NSDictionary? = {
                    if let path = Bundle.main.path(forResource: "LocalizableArrays", ofType: "plist") {
                        return NSDictionary(contentsOfFile: path)
                    }
                    return nil
                }()
                """.trimIndent()
            )
        }
    }

    private fun Document.createAndAppendPlistElement(): Element {
        val plist = createElement("plist").apply { setAttribute("version", "1.0") }
        val dict = createElement("dict")
        appendChild(plist)
        plist.appendChild(dict)
        return dict
    }

    companion object {
        private const val KEY = "key"
        private const val STRING = "string"

        private val transformer: Transformer by lazy {
            createTransformer().apply {
                setOutputProperty(OutputKeys.DOCTYPE_PUBLIC, "-//Apple//DTD PLIST 1.0//en")
                setOutputProperty(OutputKeys.DOCTYPE_SYSTEM, "http://www.apple.com/DTDs/PropertyList-1.0.dtd")
            }
        }
    }
}
