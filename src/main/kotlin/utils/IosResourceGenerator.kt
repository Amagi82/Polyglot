/*
 * Copyright (C) 2018 Jim Pekarek.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package utils

import models.*
import org.w3c.dom.Document
import org.w3c.dom.Element
import java.io.*
import java.lang.StringBuilder
import javax.xml.transform.OutputKeys
import javax.xml.transform.Transformer

/**
 * Generates iOS resources for a given language in the specified folder
 * This creates separate files for String resources, Plurals, and Arrays, which each use different
 * file types and formatting. It also generates an R file for type-safe resource access, e.g.
 * R.string.some_resource_id or R.plural.some_plural_id(quantity: 3, arg0: 3, arg1: "Mice") or
 * R.array.some_array_id, similar to Android, but providing the actual resource, not an integer.
 * Swift extension functions are generated for convenience.
 */
class IosResourceGenerator(
    private val iosFolder: File,
    private val language: Language,
    formatters: List<StringFormatter>,
    resources: Collection<Resource>
) : ResourceGenerator(Platform.IOS, formatters) {

    private val subFolder = File(iosFolder, "${language.isoCode}.lproj").also { it.mkdirs() }

    private val stringsWriter = BufferedWriter(FileWriter(subFolder.createChildFile("Localizable.strings")))

    private val pluralsDocument: Document = createDocument()
    private val pluralsResourceElement: Element = pluralsDocument.createAndAppendPlistElement()

    private val arraysDocument: Document = createDocument()
    private val arraysResourceElement: Element = arraysDocument.createAndAppendPlistElement()

    private val shouldCreatePlurals = resources.any { it.localizationType is Quantities }
    private val shouldCreateArrays = resources.any { it.localizationType is StringArray }

    private val shouldCreateReferences = language is English
    private val stringReferences = if (shouldCreateReferences) StringBuilder() else null
    private val pluralReferences = if (shouldCreateReferences) StringBuilder() else null
    private val stringArrayReferences = if (shouldCreateReferences) StringBuilder() else null

    private val generatedFileWarning = """
        /*
        * This is a generated file, do not edit!
        * Generated by Polyglot
        */
        
    """.trimIndent()

    init {
        resources.forEach(::add)
    }

    override fun add(res: Resource) {
        if (platform !in res.platforms) return
        when (res.localizationType) {
            is Str -> addString(res.id, res.localizationType)
            is Quantities -> addPlurals(res.id, res.localizationType)
            is StringArray -> addStringArray(res.id, res.localizationType)
        }
    }

    override fun generateFiles() {
        stringsWriter.close()
        if (shouldCreatePlurals) {
            transformer.transform(pluralsDocument, subFolder, "Localizable.stringsdict")
        }
        if (shouldCreateArrays) {
            transformer.transform(arraysDocument, subFolder, "LocalizableArrays.plist")
        }
        generateReferences()
        generateStringLocalizationExtensions()
    }

    /**
     * <key>duration_days</key>
     * <dict>
     *   <key>NSStringLocalizedFormatKey</key>
     *   <string>%#@value@</string>
     *   <key>value</key>
     *   <dict>
     *       <key>NSStringFormatSpecTypeKey</key>
     *       <string>NSStringPluralRuleType</string>
     *       <key>NSStringFormatValueTypeKey</key>
     *       <string>d</string>
     *       <key>one</key>
     *       <string>%d day</string>
     *       <key>other</key>
     *       <string>%d days</string>
     *   </dict>
     * </dict>
     */
    private fun addPlurals(id: String, quantities: Quantities) {
        var exampleText: String? = null
        pluralsResourceElement.appendChild(pluralsDocument, KEY, id)
        pluralsResourceElement.appendChild(pluralsDocument.createElement("dict").apply {
            appendChild(pluralsDocument, KEY, "NSStringLocalizedFormatKey")
            appendChild(pluralsDocument, STRING, "%#@value@")
            appendChild(pluralsDocument, KEY, "value")
            appendChild(pluralsDocument.createElement("dict").apply {
                appendChild(pluralsDocument, KEY, "NSStringFormatSpecTypeKey")
                appendChild(pluralsDocument, STRING, "NSStringPluralRuleType")
                appendChild(pluralsDocument, KEY, "NSStringFormatValueTypeKey")
                appendChild(pluralsDocument, STRING, "d")
                Quantity.values().forEach { quantity ->
                    val item = quantities.quantity(quantity) ?: return@forEach
                    val txt = item.fromLocale(language).sanitized(isXml = true)
                    if (exampleText == null) exampleText = txt
                    appendChild(pluralsDocument, KEY, quantity.label)
                    appendChild(pluralsDocument, STRING, txt)
                }
            })
        })
        addReference(id, exampleText ?: "", quantities)
    }

    private fun addReference(id: String, exampleText: String, localizationType: LocalizationType) {
        if (!shouldCreateReferences) return
        when (localizationType) {
            is Str -> stringReferences?.apply {
                appendReferenceComment(exampleText)
                if (exampleText.contains('%')) appendReferenceFormattingArgs(id, exampleText, false)
                else appendLine("\t\tstatic let $id = \"$id\".localized()")
            }
            is Quantities -> pluralReferences?.apply {
                appendReferenceComment(exampleText)
                appendReferenceFormattingArgs(id, exampleText, true)
            }
            is StringArray -> stringArrayReferences?.apply {
                appendReferenceComment(exampleText)
                appendLine("\t\tstatic let $id = \"$id\".localizedArray()")
            }
        }
    }

    private fun StringBuilder.appendReferenceComment(exampleText: String) {
        appendLine()
        if (exampleText.isNotEmpty()) appendLine("\t\t// en: $exampleText")
    }

    private fun StringBuilder.appendReferenceFormattingArgs(id: String, exampleText: String, isPlural: Boolean) {
        var i = exampleText.indexOf('%')

        append("\t\tstatic func $id(")
        if (isPlural) {
            append("quantity: Int")
            if (i != -1) append(", ")
        }

        var ct = 0
        while (i != -1) {
            val type = when (exampleText.getOrNull(i + 1)) {
                '@' -> "String"
                'd' -> "Int"
                'f' -> "Float"
                else -> null
            }
            if (type != null) {
                if (ct != 0) append(", ")
                append("_ arg$ct: $type")
                ct++
            }
            i = exampleText.indexOf('%', i + 1)
        }
        appendLine(") -> String {")
        append("\t\t\t\"$id\".localized")

        if (isPlural) {
            append("Plural(quantity: quantity")
            append(", ")
        } else append('(')

        (0 until ct).forEach {
            if (it != 0) append(", ")
            append("arg$it")
        }
        appendLine(')')
        appendLine("\t\t}")
    }

    private fun addString(id: String, str: Str) {
        // "identifier" = "Localized text";
        val txt = str.fromLocale(language).sanitized(isXml = false)
        stringsWriter.appendLine("\"$id\" = \"$txt\";")
        addReference(id, txt, str)
    }

    /**
     * <key>alert_cancel_reasons</key>
     * <array>
     *   <string>Time</string>
     *   <string>Wage</string>
     * </array>
     */
    private fun addStringArray(id: String, stringArray: StringArray) {
        arraysResourceElement.appendChild(arraysDocument, KEY, id)
        arraysResourceElement.appendChild(arraysDocument.createElement("array").apply {
            for (item in stringArray.items) {
                appendChild(arraysDocument, STRING, item.fromLocale(language).sanitized(isXml = true))
            }
        })
        addReference(id, "", stringArray)
    }

    private fun generateReferences() {
        if (!shouldCreateReferences) return
        iosFolder.createChildFile("R.swift").bufferedWriter().use {
            it.appendLine(generatedFileWarning)
            it.appendLine("struct R {")
            it.appendReferences("string", stringReferences)
            it.appendReferences("plural", pluralReferences)
            it.appendReferences("array", stringArrayReferences)
            it.appendLine('}')
        }
    }

    private fun BufferedWriter.appendReferences(type: String, references: StringBuilder?) {
        if (references.isNullOrEmpty()) return
        appendLine("\tstruct $type {")
        append(references)
        appendLine("\t}")
    }

    private fun generateStringLocalizationExtensions() {
        if (iosFolder.listFiles().orEmpty().any { it.name == "String+Localization.swift" }) return
        iosFolder.createChildFile("String+Localization.swift").bufferedWriter().use {
            it.appendLine(generatedFileWarning)
            it.appendLine(
                """
                import Foundation
                
                extension String {
                
                    /*
                     * Returns a localized string. If the key is not found, it will default to using itself.
                     */
                    func localized() -> String {
                        NSLocalizedString(self, value: self, comment: "")
                    }
                    
                    /*
                     * Returns a localized string formatted with any args, using self as the key. It will default to
                     * using itself if no value is found for the key.
                     */
                    func localized(_ args: CVarArg...) -> String {
                        String(format: NSLocalizedString(self, value: self, comment: ""), arguments: args)
                    }
                    
                    func localizedPlural(quantity: Int, _ args: CVarArg...) -> String {
                        var args = args
                        args.insert(quantity, at: 0)
                        return String(format: NSLocalizedString(self, value: self, comment: ""), arguments: args)
                    }
                    
                    func localizedArray() -> [String] {
                        localizedDict?[self] as? [String] ?? []
                    }
                }
                
                private var localizedDict: NSDictionary? = {
                    if let path = Bundle.main.path(forResource: "LocalizableArrays", ofType: "plist") {
                        return NSDictionary(contentsOfFile: path)
                    }
                    return nil
                }()
                """.trimIndent()
            )
        }
    }

    private fun Document.createAndAppendPlistElement(): Element {
        val plist = createElement("plist").apply { setAttribute("version", "1.0") }
        val dict = createElement("dict")
        appendChild(plist)
        plist.appendChild(dict)
        return dict
    }

    companion object {
        private const val KEY = "key"
        private const val STRING = "string"

        private val transformer: Transformer by lazy {
            createTransformer().apply {
                setOutputProperty(OutputKeys.DOCTYPE_PUBLIC, "-//Apple//DTD PLIST 1.0//en")
                setOutputProperty(OutputKeys.DOCTYPE_SYSTEM, "http://www.apple.com/DTDs/PropertyList-1.0.dtd")
            }
        }
    }
}
